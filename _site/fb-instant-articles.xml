<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title></title>
    <link>http://localhost:4000</link>
    <description>
      Is a DevOps Engineer but also kind of a hardcore gamer some might probably say. Spends most of his time with his family or while coding, eating stuff and doing something video game related.

    </description>
    
        
            <item>
                <title>Cyberpunk 2077 Review</title>
                <link>http://localhost:4000/2021/01/14/cyberpunk-2077-review</link>
                <content:encoded>
                    <![CDATA[
                    <p>Let us have a loot at one of the most ambitious titles of PC gaming in the last decade.<!--more--></p>

<p><img src="/images/site/2021-1-14-cyberpunk-2077-review/cyberpunk_logo.png" alt="Cyberpunk" class="align-right small-image" /></p>

<p>We’ve all waited and eventually after a couple of delays (four or maybe five?) we finally got the game in our hands. It was indeed among my most waited games of all time, probably were sharing the top spot with Mount &amp; Blade 2: Bannerlord at some point of time. Now Bannerlord was a good game. It was surely missing the promised features and needed a lot of polish, but the gameplay and the spirit were present. If for me, if bugs are not game-breaking, that’s all that matters. But needless to say, we live in a world where delays are constantly happening and even after those delays, companies are still lauching buggy and uncompleted games. When it comes to these sort of things, one important man comes to mind. Shigeru Miyamoto, one of Nintendo’s MVPs, creator of blockbuster series such as Mario, Donkey Kong and The Legend of the Zelda.</p>

<blockquote>“A delayed game is eventually good, but a rushed game is forever bad.”<br /> -Shigeru Miyamoto</blockquote>

<p>That’s a really good point and really demonstrates the Nintendo’s take about these sort of stuff. They act slow, they plan slow and release big and known-to-be-hit games.</p>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/2021/01/14/cyberpunk-2077-review</guid>
                <description>
                    
                    Let us have a loot at one of the most ambitious titles of PC gaming in the last decade: Cyberpunk 2077.

                    
                </description>
                <pubDate>Thu, 14 Jan 2021 00:00:00 +0300</pubDate>
                <author>Ufuk Ozdogan</author>
            </item>
        
    
        
            <item>
                <title>How to Enable Docker Remote API, Usage and Risks</title>
                <link>http://localhost:4000/2020/09/14/docker-remote-api</link>
                <content:encoded>
                    <![CDATA[
                    <p>In various situations you may in a need to control Docker outside of your host environment. Let’s say you’re deploying to a server of yours and to remote deploy you need a connection to your Docker Daemon. <!--more--> In that scenario Docker REST API connection comes to your rescue but with a little security cost. We’ll talk about that later in this post.
But first let’s enable it. Assuming that you already have a server that has Docker installed on it.</p>

<h2 id="enabling-docker-remote-api">Enabling Docker Remote API</h2>

<p>Go to <code class="language-plaintext highlighter-rouge">/lib/systemd/system</code> and edit the file <code class="language-plaintext highlighter-rouge">docker.service</code> with your favourite terminal editor. Doesn’t matter whether you’re a <em>super user</em> or not. Find the line below and edit it like this:</p>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2376 --containerd=/run/containerd/containerd.sock
</span></code></pre></div></div>

<p>This way Docker engine server will be binded to Unix socket and TCP Port 2376. You can change the port however you want but be sure that it’s not being used by any other service on your machine.</p>

<p>After editing fire up these commands:</p>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">sudo systemctl daemon-reload
sudo service docker restart
</span></code></pre></div></div>

<p>Now your remote API is enabled. Let’s test it.</p>

<h2 id="testing-docker-remote-api-connection">Testing Docker Remote API Connection</h2>

<p>Step outside from your server to anywhere else and now, you should be able to run these commands.</p>

<h3 id="with-docker">With Docker</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker -H YOUR_SERVER_IP:2376 version
</code></pre></div></div>

<h3 id="with-curl">With cURL</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://YOUR_SERVER_IP:2376/version
</code></pre></div></div>

<h3 id="with-a-rest-client">With a REST Client</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://YOUR_SERVER_IP:2376/version
</code></pre></div></div>

<h2 id="benefits-and-advanced-usage">Benefits and Advanced Usage</h2>

<p>As dangerous as this can be (ops, spoilers for next chapter), this connection also offers some undeniable benefits. For example, from your CI agent you could say:</p>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker -H YOUR_SERVER_IP:2376 pull YOUR_IMAGE
docker -H YOUR_SERVER_IP:2376 run
        --name 
        -it
        -e SAMPLE_ENV=SAMPLE_ENV_VARIABLE
        -p 80:80
</span><span class="gp">        -d $</span>YOUR_IMAGE
</code></pre></div></div>

<p>Honestly, this opens up so many options and enhances your reach on environments.</p>

<h2 id="risks-and-side-effects">Risks and Side Effects</h2>

<p>Take a moment the notice that the definition of the IP address we gave in the <em>docker.service</em> file. <code class="language-plaintext highlighter-rouge">0.0.0.0</code> means that <strong>any person</strong> who has the IP of your server and port of the Docker can connect to your Docker engine without hesitation. Opened ports are easily findable via various easy techniques thus your environment can be instantly vulnerable to attack. Take a look at this <a href="https://www.riccardoancarani.it/attacking-docker-exposed-api/">article</a> about attacking exposing Docker API’s to have a grasp on the situation.</p>

<p>There are various solutions such as <a href="https://ahmet.im/blog/docker-http-basic-auth/">HTTP Basic Authentication with Nginx</a>, adding a <a href="https://gist.github.com/kekru/974e40bb1cd4b947a53cca5ba4b0bbe5">TLS client certificate verification</a> to Docker API. Personally I came up with another solution. I’ll edit this part when I wrote the article about it.</p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://success.docker.com/article/how-do-i-enable-the-remote-api-for-dockerd">https://success.docker.com/article/how-do-i-enable-the-remote-api-for-dockerd</a></li>
  <li><a href="https://docs.docker.com/develop/sdk/examples/">https://docs.docker.com/develop/sdk/examples/</a></li>
  <li><a href="https://medium.com/@sudarakayasindu/enabling-and-accessing-docker-engine-api-on-a-remote-docker-host-on-ubuntu-16-04-2c15f55f5d39">https://medium.com/@sudarakayasindu/enabling-and-accessing-docker-engine-api-on-a-remote-docker-host-on-ubuntu-16-04-2c15f55f5d39</a></li>
  <li><a href="https://scriptcrunch.com/enable-docker-remote-api/">https://scriptcrunch.com/enable-docker-remote-api/</a></li>
</ul>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/2020/09/14/docker-remote-api</guid>
                <description>
                    
                    In various situations you may in a need to control Docker outside of your host environment. Let's say you're deploying to a server of yours and to remote deploy you need a connection to your Docker Daemon.

                    
                </description>
                <pubDate>Mon, 14 Sep 2020 00:00:00 +0300</pubDate>
                <author>Ufuk Ozdogan</author>
            </item>
        
    
  </channel>
</rss>
